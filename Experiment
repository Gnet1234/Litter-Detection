import multiprocessing
import os
import csv
import tempfile
import cv2
import numpy as np
import queue
import inputs
from ultralytics import YOLO
import olympe
from olympe.messages.ardrone3.Piloting import TakeOff, Landing, moveBy
from olympe.messages.ardrone3.PilotingState import FlyingStateChanged

# Set Olympe logging level to WARNING to reduce verbosity
olympe.log.update_config({"loggers": {"olympe": {"level": "WARNING"}}})

DRONE_IP = os.getenv("DRONE_IP", "192.168.42.1")
DRONE_RTSP_PORT = os.getenv("DRONE_RTSP_PORT")

# Load YOLO model
Model_Path = r"/home/labpc/Downloads/yolov8n-seg.pt"
model = YOLO(Model_Path)

class StreamingExample:
    def __init__(self):
        self.drone = olympe.Drone(DRONE_IP)
        self.tempd = tempfile.mkdtemp(prefix="olympe_streaming_test_")
        print(f"Olympe streaming example output dir: {self.tempd}")
        self.h264_frame_stats = []
        self.h264_stats_file = open(os.path.join(self.tempd, "h264_stats.csv"), "w+")
        self.h264_stats_writer = csv.DictWriter(self.h264_stats_file, ["fps", "bitrate"])
        self.h264_stats_writer.writeheader()
        self.frame_queue = multiprocessing.Queue()
        self.processed_frame_queue = multiprocessing.Queue()
        self.processes = []
        self.frame_skip = 5  # Process every 5th frame

    def start(self):
        assert self.drone.connect(retry=3)

        if DRONE_RTSP_PORT is not None:
            self.drone.streaming.server_addr = f"{DRONE_IP}:{DRONE_RTSP_PORT}"

        self.drone.streaming.set_output_files(
            video=os.path.join(self.tempd, "streaming.mp4"),
            metadata=os.path.join(self.tempd, "streaming_metadata.json"),
        )

        self.drone.streaming.set_callbacks(
            raw_cb=self.yuv_frame_cb,
            h264_cb=self.h264_frame_cb,
            start_cb=self.start_cb,
            end_cb=self.end_cb,
            flush_raw_cb=self.flush_cb,
        )
        self.drone.streaming.start()

        # Start multiple processing threads
        num_processes = multiprocessing.cpu_count()
        self.processes = [multiprocessing.Process(target=self.yuv_frame_processing) for _ in range(num_processes)]
        for p in self.processes:
            p.start()

        self.process_video_output()

    def stop(self):
        for p in self.processes:
            p.terminate()
            p.join()

        assert self.drone.streaming.stop()
        assert self.drone.disconnect()
        self.h264_stats_file.close()

    def yuv_frame_cb(self, yuv_frame):
        yuv_frame.ref()
        frame_info = yuv_frame.info()
        height, width = frame_info["raw"]["frame"]["info"]["height"], frame_info["raw"]["frame"]["info"]["width"]
        yuv_data = yuv_frame.as_ndarray().reshape((height * 3 // 2, width))
        bgr_frame = cv2.cvtColor(yuv_data, cv2.COLOR_YUV2BGR_I420)
        yuv_frame.unref()

        # Skip frames to reduce processing load
        if yuv_frame.info()["frame"]["frame_number"] % self.frame_skip == 0:
            self.frame_queue.put(bgr_frame)

    def yuv_frame_processing(self):
        while True:
            try:
                bgr_frame = self.frame_queue.get(timeout=0.1)
            except queue.Empty:
                continue

            bgr_frame_resized = cv2.resize(bgr_frame, (640, 480))
            results = model(bgr_frame_resized)
            annotated_frame = results[0].plot()
            self.processed_frame_queue.put(annotated_frame)

    def process_video_output(self):
        while True:
            try:
                frame = self.processed_frame_queue.get(timeout=0.1)
            except queue.Empty:
                continue

            cv2.imshow('Machine Vision', frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        cv2.destroyAllWindows()

    def flush_cb(self, stream):
        if stream["vdef_format"] != olympe.VDEF_I420:
            return True
        while not self.frame_queue.empty():
            self.frame_queue.get_nowait()
        return True

    def start_cb(self):
        pass

    def end_cb(self):
        pass

    def h264_frame_cb(self, h264_frame):
        frame_pointer, frame_size = h264_frame.as_ctypes_pointer()
        info = h264_frame.info()
        frame_ts = info["ntp_raw_timestamp"]
        if not info["is_sync"]:
            while self.h264_frame_stats and (self.h264_frame_stats[0][0] + 1e6) < frame_ts:
                self.h264_frame_stats.pop(0)
            self.h264_frame_stats.append((frame_ts, frame_size))
            h264_fps = len(self.h264_frame_stats)
            h264_bitrate = 8 * sum(size for _, size in self.h264_frame_stats)
            self.h264_stats_writer.writerow({"fps": h264_fps, "bitrate": h264_bitrate})

    def fly(self):
        try:
            while True:
                events = inputs.get_gamepad()
                for event in events:
                    if event.ev_type == 'Absolute':
                        if event.code == 'ABS_X':
                            x_value = event.state
                            if x_value > 20000:
                                self.drone(moveBy(0, 1, 0, 0)).wait()
                                print("Moving Right")
                            elif x_value < -20000:
                                self.drone(moveBy(0, -1, 0, 0)).wait()
                                print("Moving Left")
                            else:
                                self.drone(moveBy(0, 0, 0, 0)).wait()
                        elif event.code == 'ABS_Y':
                            y_value = event.state
                            if y_value > 20000:
                                self.drone(moveBy(-1, 0, 0, 0)).wait()
                                print("Moving Backwards")
                            elif y_value < -20000:
                                self.drone(moveBy(1, 0, 0, 0)).wait()
                                print("Moving Forwards")
                            else:
                                self.drone(moveBy(0, 0, 0, 0)).wait()
                        elif event.code == 'ABS_RY':
                            y_value2 = event.state
                            if y_value2 > 20000:
                                self.drone(moveBy(0, 0, -1, 0)).wait()
                                print("Moving Downwards")
                            elif y_value2 < -20000:
                                self.drone(moveBy(0, 0, 1, 0)).wait()
                                print("Moving Upwards")
                            else:
                                self.drone(moveBy(0, 0, 0, 0)).wait()
                    elif event.ev_type == 'Key':
                        if event.code == 'BTN_SOUTH' and event.state == 1:
                            self.drone(TakeOff())
                            print("TakeOff")
                        elif event.code == 'BTN_EAST' and event.state == 1:
                            self.drone(Landing())
                            print("Landing")
                        elif event.code == 'BTN_WEST' and event.state == 1:
                            self.drone(moveBy(0, 0, 0, 1)).wait()
                            print("Turning clockwise")
                        elif event.code == 'BTN_NORTH' and event.state == 1:
                            self.drone(moveBy(0, 0, 0, -1)).wait()
                            print("Turning counter clockwise")
        except KeyboardInterrupt:
            print("Stopping control with Xbox controller...")

        print("Landing...")
        self.drone(Landing() >> FlyingStateChanged(state="landed", _timeout=5)).wait()
        print("Landed\n")

    def replay_with_vlc(self):
        mp4_filepath = os.path.join(self.tempd, "streaming.mp4")
        subprocess.run(shlex.split(f"vlc --play-and-exit {mp4_filepath}"), check=True)

def test_streaming():
    streaming_example = StreamingExample()
    streaming_example.start()
    streaming_example.fly()
    streaming_example.stop()

if __name__ == "__main__":
    test_streaming()
