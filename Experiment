from ultralytics import YOLO
import cv2
import multiprocessing
import tempfile
import os
import csv
import olympe
from olympe.messages.ardrone3.Piloting import TakeOff, Landing
from olympe.messages.ardrone3.Piloting import moveBy
from olympe.messages.ardrone3.PilotingState import FlyingStateChanged
import inputs
import numpy as np

olympe.log.update_config({"loggers": {"olympe": {"level": "WARNING"}}})

DRONE_IP = os.environ.get("DRONE_IP", "192.168.42.1")
DRONE_RTSP_PORT = os.environ.get("DRONE_RTSP_PORT")

Model_Path = r"/home/labpc/Downloads/yolov8n-seg.pt"
model = YOLO(Model_Path)

class StreamingExample:
    def __init__(self):
        self.drone = olympe.Drone(DRONE_IP)
        self.tempd = tempfile.mkdtemp(prefix="olympe_streaming_test_")
        print(f"Olympe streaming example output dir: {self.tempd}")
        self.h264_frame_stats = []
        self.h264_stats_file = open(os.path.join(self.tempd, "h264_stats.csv"), "w+")
        self.h264_stats_writer = csv.DictWriter(
            self.h264_stats_file, ["fps", "bitrate"]
        )
        self.h264_stats_writer.writeheader()
        self.frame_queue = multiprocessing.Queue()
        self.processes = []

    def start(self):
        assert self.drone.connect(retry=3)

        if DRONE_RTSP_PORT is not None:
            self.drone.streaming.server_addr = f"{DRONE_IP}:{DRONE_RTSP_PORT}"

        self.drone.streaming.set_output_files(
            video=os.path.join(self.tempd, "streaming.mp4"),
            metadata=os.path.join(self.tempd, "streaming_metadata.json"),
        )

        self.drone.streaming.set_callbacks(
            raw_cb=self.yuv_frame_cb,
            h264_cb=self.h264_frame_cb,
            start_cb=self.start_cb,
            end_cb=self.end_cb,
            flush_raw_cb=self.flush_cb,
        )
        self.drone.streaming.start()

        # Start multiple processing threads
        num_processes = multiprocessing.cpu_count()
        self.processes = [multiprocessing.Process(target=self.yuv_frame_processing) for _ in range(num_processes)]
        for p in self.processes:
            p.start()

    def stop(self):
        for p in self.processes:
            p.terminate()
            p.join()

        assert self.drone.streaming.stop()
        assert self.drone.disconnect()
        self.h264_stats_file.close()

    def yuv_frame_cb(self, yuv_frame):
        yuv_frame.ref()
        frame_info = yuv_frame.info()
        height, width = frame_info["raw"]["frame"]["info"]["height"], frame_info["raw"]["frame"]["info"]["width"]
        yuv_data = yuv_frame.as_ndarray()
        yuv_data = yuv_data.reshape((height * 3 // 2, width))
        bgr_frame = cv2.cvtColor(yuv_data, cv2.COLOR_YUV2BGR_I420)
        yuv_frame.unref()
        # Convert the frame to a picklable format
        self.frame_queue.put(bgr_frame)

    def yuv_frame_processing(self):
        while True:
            try:
                bgr_frame = self.frame_queue.get(timeout=0.1)
            except queue.Empty:
                continue

            bgr_frame_resized = cv2.resize(bgr_frame, (640, 480))
            results = model(bgr_frame_resized)
            annotated_frame = results[0].plot()

            cv2.imshow('Machine Vision', annotated_frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        cv2.destroyAllWindows()

    def flush_cb(self, stream):
        if stream["vdef_format"] != olympe.VDEF_I420:
            return True
        while not self.frame_queue.empty():
            self.frame_queue.get_nowait()
        return True

    def start_cb(self):
        pass

    def end_cb(self):
        pass

    def h264_frame_cb(self, h264_frame):
        frame_pointer, frame_size = h264_frame.as_ctypes_pointer()
        info = h264_frame.info()
        frame_ts = info["ntp_raw_timestamp"]
        if not bool(info["is_sync"]):
            while len(self.h264_frame_stats) > 0:
                start_ts, _ = self.h264_frame_stats[0]
                if (start_ts + 1e6) < frame_ts:
                    self.h264_frame_stats.pop(0)
                else:
                    break
            self.h264_frame_stats.append((frame_ts, frame_size))
            h264_fps = len(self.h264_frame_stats)
            h264_bitrate = 8 * sum(map(lambda t: t[1], self.h264_frame_stats))
            self.h264_stats_writer.writerow({"fps": h264_fps, "bitrate": h264_bitrate})

    def fly(self):
        try:
            while True:
                events = inputs.get_gamepad()
                for event in events:
                    if event.ev_type == 'Absolute':
                        if event.code == 'ABS_X':
                            x_value = event.state
                            if x_value > 20000:
                                self.drone(moveBy(0, 1, 0, 0)).wait()
                                print("Moving Right")
                            elif x_value < -20000:
                                self.drone(moveBy(0, -1, 0, 0)).wait()
                                print("Moving Left")
                            elif abs(x_value) <= 20000:
                                self.drone(moveBy(0, 0, 0, 0)).wait()
                        elif event.code == 'ABS_Y':
                            y_value = event.state
                            if y_value > 20000:
                                self.drone(moveBy(-1, 0, 0, 0)).wait()
                                print("Moving Backwards")
                            elif y_value < -20000:
                                self.drone(moveBy(1, 0, 0, 0)).wait()
                                print("Moving Forwards")
                            elif abs(y_value) <= 20000:
                                self.drone(moveBy(0, 0, 0, 0)).wait()
                        elif event.code == 'ABS_RY':
                            y_value2 = event.state
                            if y_value2 > 20000:
                                self.drone(moveBy(0, 0, -1, 0)).wait()
                                print("Moving Downwards")
                            elif y_value2 < -20000:
                                self.drone(moveBy(0, 0, 1, 0)).wait()
                                print("Moving Upwards")
                            elif abs(y_value2) <= 20000:
                                self.drone(moveBy(0, 0, 0, 0)).wait()
                    elif event.ev_type == 'Key':
                        if event.code == 'BTN_SOUTH' and event.state == 1:
                            self.drone(TakeOff())
                            print("TakeOff")
                        elif event.code == 'BTN_EAST' and event.state == 1:
                            self.drone(Landing())
                            print("Landing")
                        elif event.code == 'BTN_WEST' and event.state == 1:
                            self.drone(moveBy(0, 0, 0, 1)).wait()
                            print("Turning clockwise")
                        elif event.code == 'BTN_NORTH' and event.state == 1:
                            self.drone(moveBy(0, 0, 0, -1)).wait()
                            print("Turning counter clockwise")
        except KeyboardInterrupt:
            print("Stopping control with Xbox controller...")

        print("Landing...")
        self.drone(Landing() >> FlyingStateChanged(state="landed", _timeout=5)).wait()
        print("Landed\n")

    def replay_with_vlc(self):
        mp4_filepath = os.path.join(self.tempd, "streaming.mp4")
        subprocess.run(shlex.split(f"vlc --play-and-exit {mp4_filepath}"), check=True)

def test_streaming():
    streaming_example = StreamingExample()
    streaming_example.start()
    streaming_example.fly()
    streaming_example.stop()

if __name__ == "__main__":
    test_streaming()
